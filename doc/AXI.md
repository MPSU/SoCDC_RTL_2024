## Содержание

- [Введение](#введение)
  - [Что такое стандарт AMBA и зачем его использовать](#что-такое-стандарт-amba-и-зачем-его-использовать)
  - [Развитие AMBA](#развитие-amba)

- [Протокол AXI](#протокол-axi)
  - [Каналы AXI](#каналы-axi)
  - [Handshake](#handshake)
  - [Глобальные сигналы](#глобальные-сигналы)
  - [Сигналы каналов](#сигналы-каналов)
  - [Транзакция записи данных](#каналы-для-транзакции-записи)
  - [Транзакция чтения данных](#каналы-для-транзакции-чтения)
  - [Взаимодействие каналов](#взаимодействие-каналов)
    - [Зависимости транзакции чтения](#зависимости-транзакции-чтения)
    - [Зависимости транзакции записи](#зависимости-транзакции-записи)

# Введение

## Что такое стандарт AMBA и зачем его использовать
`Advanced Microcontroller Bus Architecture`(`AMBA`) — открытый стандарт требований внутрикристалльных межсоединений фирмы `ARM` для соединения и управления функциональными блоками в разработках систем на кристалле. По сути, **протоколы `AMBA` определяют, как функциональные блоки взаимодействуют друг с другом**.


![image](/doc/img/axi_interconnect.png)

`AMBA` упрощает разработку систем с одним или несколькими процессорами и большим количеством контроллеров и/или периферийных устройств. Сегодня `AMBA` широко используется в различных компонентах систем на кристалле, включающих в себя процессорные ядра общего назначения и  использующихся в подсистемах Интернета вещей, смартфонах, либо же в высокопроизводительных серверных системах.

## Развитие AMBA

![img](/doc/img/axi_evolution.png)

### AMBA 1

`AMBA` была представлена `ARM` в 1996 году. Первыми шинами AMBA стали `Advanced System Bus (ASB)`, которая позднее была вытеснена более современными протоколами, и `Advanced Peripheral Bus (APB)`, широко использующаяся и сегодня. `APB` была разработана для передачи с низкой пропускной способностью, к примеру, для низкоскоростных периферийных интерфейсов. Шина содержит небольшой список сигналов с относительно простым способом их связи.

### AMBA 2
В 1999 `AMBA 2` `ARM` добавила протокол `AMBA High-performance Bus (AHB)`. В данном протоколе для передачи информации от источника к приемнику используется **только** нарастающий фронт тактового сигнала, а не восходящий и нисходящий, как это было реализовано в `ASB`. Простая транзакция в протоколе происходит за две фазы: передачи адреса и следующей за этим передачи данных. Доступ к нужному устройству контролируется за счет мультиплексора, предоставляющего доступ только к одному ведущему устройству за раз. Для увеличения производительности `AHB`поддерживает конвейеризованные транзакции, в отличие от `APB`. В свою очередь, построение дизайна по протоколу `APB` проще.

### AMBA 3
В 2003 году `ARM` представила третье поколение `AMBA 3`, включающее в себя `Advanced Trace Bus (ATB)`, `AHB-Lite`, `Advanced eXtensible Interface (AXI)`.

`ATB` является частью решения `CoreSight` для отладки и трассировки системы на кристалле.

Протокол `AHB-Lite` является подмножеством `AHB`, который упрощает конструкцию шины, но оставляет в ней только возможность работы с одним ведущим устройством.

Протокол `AXI` предназначен для систем с высокой производительностью и высокой тактовой частотой и включает возможности, которые делают его пригодным для реализации высокоскоростных шин в микросхемах, изготовленных с современными фотолитографическими нормами.

### AMBA 4
В 2010-2011 году фирмой `ARM` были представлены спецификации `AMBA 4`, начиная с `AMBA 4 AXI4`, заканчивая `AMBA 4 AXI Coherency Extensions (ACE)`.

`ACE` расширяет каналы чтения и записи данных `AXI`,  вводя отдельные каналы отслеживания адреса, отслеживания данных и отслеживания ответа. Эти дополнительные каналы предоставляют механизмы для реализации протокола когерентности на основе отслеживания.

Протокол `ACE-Lite` обеспечивает однонаправленную когерентность, которая позволяет производить когерентное считывание данных из кэш-памяти процессора.

Протокол `AXI4-Stream` предназначен для однонаправленной передачи данных от ведущего устройства к ведомому с опциональной маршрутизацией. Например, на базе `AXI4-Stream` можно строить производительные конвейеры для цифровой обработки сигналов.

`AXI-Lite` — это упрощенная версия `AXI`, в нем отсутствует поддержка пакетной передачи данных.

### AMBA 5
В 2014 году была представлена спецификация `AMBA 5` `Coherent Hub Interface (CHI)` с переработанным высокоскоростным транспортным уровнем и функциями, предназначенными для увеличения удельной пропускной способности. Протокол `CHI` использует многоуровневый пакетный протокол связи с реализацией протокольного, канального и физического уровней, а также поддерживает механизмы управления потоками данных и повторных отправок данных.

В 2016 году  протокол `AHB-Lite` был обновлен до версии `AHB5`, дополняющей архитектуру `Armv8-M` и расширяющей действие функции безопасности `TrustZone` от процессорного ядра до системы в целом.

В 2019 году был выпущен `Adaptive Traffic Profiles (ATP)`, дополняющий существующие протоколы `AMBA`. `ATP` используется для моделирования высокоуровневого доступа к памяти.

# Протокол AXI
`Advanced eXtensible Interface`(`AXI`) — стандарт связи, разработанный `ARM`, как часть стандарта `AMBA`. Протокол `AXI` описывает способ, посредством которого встроенные компоненты могут взаимодействовать друг с другом при помощи сигналов, обычно с участием ведущего и ведомого устройства. Существует три типа интерфейсов `AXI4` (определенных AMBA 4.0):
 - **AXI4 (Full AXI)** — высокопроизводительный интерфейс данных с использованием отображения адресов в памяти (т.е ведущим устройством указывается адрес для чтения или записи) и возможностью пакетной передачи данных.
 - **AXI-Lite** — легкий и простой интерфейс с отображением адресов в памяти, поддерживающий только **одну** передачу данных за транзакцию.
 - **AXI4-Stream** — "прямая" связь с устройством, устраняющая необходимость в адресах и обеспечивающая максимальную передачу данных.

## Каналы AXI
Спецификация `AXI` описывает протокол связи двух интерфейсов: ведущего устройства (Master) и ведомого (Slave), связь осуществляется в рамках пяти однонаправленных каналов:

  * Канал `Write Address (AW)` — используется для передачи адреса, по которому ведущее устройство хочет произвести запись.
  * Канал `Write Data (W)` — используется для передачи от ведущего устройства данных, которые должны быть записаны в ведомое устройство.
  * Канал `Write Response (B – buffered)` — используется для ответа ведомого устройства при транзакции записи.
  * Канал `Read Address (AR)` — используется для передачи адреса, по которому ведущее устройство хочет считать данные.
  * Канал `Read Data (R)` — используется для передачи ведущему устройству данных, считанных из ведомого устройства.

![](/doc/img/axi_channels.drawio.svg)

## Handshake

Прежде чем рассматривать то, как взаимодействуют каналы между собой, необходимо рассмотреть такое понятие, как **Handshake** или **Рукопожатие**.

### Handshake модель

Предположим, есть **источник** (`Source`), которому необходимо передавать данные **приемнику** (`Destination`). Источник и приемник являются равноправными партнерами в обмене данными: источник не может заставить получателя принять данные, а получатель не может заставить источник отправить корректные данные. **Чтобы передача данных произошла, обеим сторонам необходимо "пожать друг другу руки"**. Для этого **рукопожатия** у источника должны быть достоверные данные, а приемник должен быть готов к их получению.

**Все каналы внутри `AXI` используют один механизм передачи, основанный на `Valid`, `Ready` сигналах. Для каждого канала эта пара сигналов своя.**

![axi_handshake](/doc/img/axi_handshake.drawio.svg)

  - Сигнал `Valid` поднимает (выставляет в логическую единицу) **источник**, чтобы показать **приёмнику**, что данные сформированы для передачи, т.e. являются "**валидными**". В качестве источника может выступать как `Master` (пример: канал `WriteData`), так и `Slave` (пример: канал `ReadAddress`).

  - Сигнал `Ready` поднимает **получатель** в момент, когда он **готов** принять данные **источника**.

`Handshake` считается случившимся, если `Valid` источника и `Ready` приемника выставлены одновременно во время возрастающего фронта тактового сигнала [`ACLK`](#aclk).

### Пример. Valid до Ready

![axi_valid_before_ready](/doc/img/axi_valid_before_ready.svg)

В данном примере на **первом такте** источник формирует данные и поднимает сигнал `Valid`. На **втором такте** получатель поднимает сигнал готовности `Ready`, и **на третьем такте** происходит `handshake`и осуществляется передача данных.

> Источник при выставлении `Valid` обязан держать данные и не изменять их до тех пор, пока не случится передача. **Изменения данных источника до их передачи недопустимо**.

> Источник **не может** опускать `Valid` до того, как произойдет `handshake`.

> Источник **НЕ может** ждать установки `Ready` для того, чтобы выставить `Valid`. Однако приёмник **может** ждать `Valid` источника для выставления сигнала `Ready`.

### Пример. Ready до Valid

![axi_ready_before_valid](/doc/img/axi_ready_before_valid.svg)

В данном примере приемник поднимает `Ready` на **первом такте**, однако источник ещё не выставил данные для передачи. На **втором такте** источник выставляет данные для передачи и сигнал `Valid`. На **третьем такте** происходит `handshake` и осуществляется передача данных.

> Допустимо, чтобы приемник ожидал установку сигнала `Valid` источника до установки сигнала `Ready`. Однако источник **не может** ожидать сигнала `Ready` для установки `Valid`.

> Приемник **может** опустить сигнал `Ready` до того, как произойдет `handshake`.

### Пример. Valid одновременно с Ready
![axi_ready_valid](/doc/img/axi_ready_valid.svg)

В данном примере на **первом такте** источник выставляет данные для передачи вместе с сигналом `Valid`, одновременно с этим получатель поднимает сигнал готовности к приёму данных `Ready`. На **втором такте** происходит `handshake` и осуществляется передача данных.

> Источник при выставлении `Valid` обязан держать данные и не изменять их до тех пор, пока не случится передача. **Изменения данных источника до их передачи недопустимо**.

> Источник **не может** опускать `Valid` до того, как произойдет `handshake`.

> Приемник **может** опустить сигнал `Ready` до того, как произойдет `handshake`.

## Глобальные сигналы
| Сигнал      | Источник         | Описание                                                                                                                     |
| ----------- | ---------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **ACLK**    | Источник частоты | Глобальный сигнал частоты. Применим для всех компонентов внутри AXI.                                                         |
| **ARESETn** | Источник сброса | Глобальный сигнал сброса, активный уровень "0". Может быть установлен асинхронно, но **снятие** **синхронно** с фронтом ACLK |

### ACLK

Каждый компонент `AXI` использует один тактовый сигнал, `ACLK`. Все входные сигналы отбираются по положительному фронту `ACLK`. Все изменения выходного сигнала должны происходить после положительного фронта `ACLK`. 

### ARESETn

Протокол `AXI` использует один активный сигнал сброса низкого уровня, `ARESETn`. Сигнал сброса может быть установлен асинхронно, но **снятие должно быть синхронным** с фронтом `ACLK`. Во время сброса применяются следующие требования к интерфейсу:
- `Master` должен установить `ARVALID`, `AWVALID`, `WVALID` в низкий уровень.
- `Slave` должен установить `RVALID`, `BVALID` в низкий уровень.
- Все остальные сигналы могут быть в любом значении.

## Сигналы каналов
В текущем разделе рассматриваются сигналы, свойственные стандарту передачи, использующемуся в контексте задачи хакатона. Он основан на протоколе AXI-Lite, но в отличие от него, использует меньше сигналов.

### Каналы записи

Каналы записи используются для передачи данных, которые ведущее устройство хочет передать ведомому для их записи, а также для ответа ведомого устройства о статусе завершенной транзакции.

#### Write Address

| Сигнал       | Источник | Описание                                                                                                                                                       |
| ------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **AWADDR**   | Master   | Адрес записи. Адрес, по которому должны записаться данные                                                                                                      |
| **AWVALID**  | Master   | Действительные данные. Этот сигнал указывает на то, что ведущее устройство передает действительный адрес записи                                                |
| **AWREADY**  | Slave    | Готовность передачи. Этот сигнал указывает на то, что ведомое устройство готово принять адрес                                                                  |

#### Write Data
| Сигнал     | Источник | Описание                                                                                                                             |
| ---------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| **WDATA**  | Master   | Данные на запись                                                                                                                     |
| **WSTRB**  | Master   | Стробирование записи. Данный сигнал указывает, какие байты в слове содержат действительные данные                                    |
| **WVALID** | Master   | Действительные данные. Этот сигнал указывает на то, что ведущее устройство передает действительные данные на запись и стробирование  |
| **WREADY** | Slave    | Готовность передачи. Этот сигнал указывает на то, что ведомое устройство готово принять данные на запись                             |

#### Write Response
| Сигнал     | Источник | Описание                                                                                                       |
| ---------- | -------- | -------------------------------------------------------------------------------------------------------------- |
| **BRESP**  | Slave    | Ответ на запись. Этот сигнал передает статус транзакции записи                                                 |
| **BVALID** | Slave    | Действительные данные. Этот сигнал показывает, что ведомое устройство сигнализирует о действительном ответе    |
| **BREADY** | Master   | Готовность передачи. Этот сигнал указывает на то, что ведущее устройство может принять запись ответа           |

### Каналы чтения
Каналы чтения используются для передачи данных, считанных с ведомого устройства, а также для передачи ответа о статусе завершенной транзакции.

#### Read Address

| Сигнал       | Источник | Описание                                                                                                                                                       |
| ------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ARADDR**   | Master   | Адрес чтения. Адрес, по которому происходит считывание данных                                                                                                  |
| **ARVALID**  | Master   | Действительные данные. Этот сигнал указывает на то, что ведущее устройство передает действительный адрес чтения                                                |
| **ARREADY**  | Slave    | Готовность передачи. Этот сигнал указывает на то, что ведомое устройство готово принять адрес чтения                                                           |

#### Read Data

| Сигнал     | Источник | Описание                                                                                                                       |
| ---------- | -------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **RDATA**  | Slave    | Данные на чтение                                                                                                               |
| **RRESP**  | Slave    | Ответ на чтение. Этот сигнал передает статус транзакции чтения                                                                 |
| **RVALID** | Slave    | Действительные данные. Этот сигнал указывает на то, что ведомое устройство передает действительные считанные данные            |
| **RREADY** | Master   | Готовность передачи. Этот сигнал указывает на то, что ведущее устройство может принять считанные данные и информацию об ответе |

## Каналы для транзакции записи
`Master` отправляет в `Slave` адрес и данные для записи по каналам `Write Adress`(AW) и `Write Data`(W) соответсвенно.
`Slave` записывает полученные данные по указанному адресу. По завершении записи `Slave` передает ответ по `Write Respose`(B) каналу.

Таким образом, для записи данных по протоколу используются три канала:
  * `Write address` для передачи адреса записи данных от ведущего устройства к ведомому.
  * `Write Data` для передачи данных от ведущего устройства к ведомому.
  * `Write Response` для подтверждения того, что в ведущее устройство была произведена (или нет) запись.

![axi_schem_write](/doc/img/axi_scheme_write.drawio.svg)

На рисунке Х на временной диграмме показан **пример** такой транзакции:
  * **Канал Write Address:**
     1. Ведущее устройство на **первом такте** выставляет на `AWADDR` адрес, по которому ведомое устройство должно записать данные, и сигнал `AWVALID`, свидетельствующий о том, что передается корректный адрес.
     2. Ведомое устройство готово для приёма данных, поэтому поднимает сигнал `AWREADY` на **втором такте**.
     3. На **третьем такте** происходит `handshake`, данные передаются.

  * **Канал Write Data:**
     1. Ведущее устройство на **пятом такте** выставляет на `WDATA` данные для записи, `WSTRB`, а также сигнал `WVALID`, свидетельствующий о том, что передаются корректные данные.
     2. Ведомое устройство готово для приёма данных, поэтому поднимает сигнал `AWREADY` на **пятом такте**.
     3. На **шестом такте** такте происходит `handshake`, данные передаются.

  * **Канал Write Response:**
     1. Ведущее устройство готово для приёма данных, поэтому поднимает сигнал `BREADY` на **пятом такте**.
     2. Ведомое устройство после успешной записи данных на **шестом такте** на `BRESP` выставляет ответ для ведущего устройства и поднимает сигнал `BVALID`.
     3. На **седьмом такте** такте происходит `handshake`, данные передаются.

![axi_wave_write](/doc/img/axi_wave_write.png)

> Нужно отметить, что данные для записи (канал `Write Data`) могут передаваться до адреса записи (канал `Write Address`). Это возможно, когда канал адреса записи имеет бóльшую пропускную способность, чем канал записи данных. Аналогично, данные на запись могут передаваться и на том же такте, что и адрес.

Сигналы `handshake` пар для каналов записи используются следующие

| Канал транзакции | handshake пара сигналов |
| ---------------- | ------------------------ |
| Write address    | `AWVALID`,`AWREAD`       |
| Write data       | `WVALID`, `WREADY`       |
| Write response   | `BVALID`, `BREADY`       |

## Каналы для транзакции чтения
`Master` выставляет адрес, по которому он хочет прочитать данные, в канале `Read Adress`(AR). `Slave` выставляет считанные данные, а также статус (успех или неудачу) транзакции чтения, в канале `Read Data`(R).

> Все каналы однонаправленны. Так как ответ от ведомого устройства может быть возвращен вместе с данными внутри канала `Read Data`, то в отдельном канале передачи ответа, как это было в случае транзакции записи (в канале `Write Response`),нет необходимости.

Таким образом, для чтения данных по протоколу используются два канала:
  * `Read address` для передачи адреса считываемых данных от ведущего устройства к ведомому.
  * `Read Data` для передачи считанных данных и статуса транзакции от ведомого устройства к ведущему.

![axi_schem_read](/doc/img/axi_scheme_read.drawio.svg )

На рисунке Х на временной диграмме показан **пример** такой транзакции:
  * Канал Read Address:
     1. Ведущее устройство на **первом такте** выставляет на `ARADDR` адрес, по которому ведомое устройство должно считать данные, и сигнал `ARVALID`, свидетельствующий о том, что передается корректный адрес.
     2. Ведомое устройство готово для приёма данных, поэтому поднимает сигнал `AWREADY` на **втором такте**.
     3. На **третьем такте** происходит `handshake`, данные передаются.

  * Канал Read Data:
     1. Ведущее устройство поднимает сигнал готовности к передаче `AWREADY` на **четвертом такте**.
     2. Ведомое устройство на **пятом такте** выставляет считанные данные на `RDATA`, статус транзакции чтения на `RRESP`, а также поднимает сигнал готовности данных `RVALID`.
     3. На **шестом такте** такте происходит `handshake`, данные передаются.

> В отличие от транзакции записи данных, в данном типе транзакции считанные данные (канал `Read Data`) не могут передаваться раньше адреса (канал `Read Address`). И действительно, невозможно корректно считать данные, не зная адрес для чтения.

![axi_wave_read](/doc/img/axi_wave_read.png )

Сигналы `handshake` пар для каналов чтения используются следующие

| Канал транзакции | handshake пара сигналов |
| ---------------- | ------------------------ |
| Read address     | `ARVALID`, `ARREADY`     |
| Read data        | `RVALID`, `RREADY`       |

## Взаимодействие каналов

Необходимо соблюдать правила зависимости, существующие между сигналами `handshake`.

Как уже было сказано:
- Сигнал `Valid` интерфейса `AXI`, передающего информацию, не должен зависеть от сигнала `Ready` интерфейса `AXI`, получающего эту информацию.
- Интерфейс `AXI`, который принимает информацию, может ждать сигнал `Valid` перед установкой сигнала `Ready`.

Необходимо отметить существующие зависимости между `handshake` сигналами на разных каналах.

В диаграммах зависимости далее:
- Одинарные стрелки указывают на сигналы, которые **могут** зависеть от сигнала в начале стрелки.
- Двойные стрелки указывают на сигналы, которые **должны** зависеть от сигнала в начале стрелки.

### Зависимости транзакции чтения
Рисунок ниже показывает зависимости сигналов для `handshake`-а транзакции чтения.

Напомним, что для осуществления транзакции чтения необходимо взаимодействие двух каналов: `Read Address`(AR) и `Read Data`(R). Далее рассмотрим связи между сигналами `Valid` и `Ready` внутри этих каналов.

В общем случае зависимости выстраиваются следующие:

![](/doc/img/axi_reading_dependencies.png)

Разберем эти зависимости:
> - `Master` **должен** поднять сигнал `ARVALID` независимо от выставления `Slave`-ом сигнала `ARREADY`.
> - `Slave` **может** поднять `ARREADY` в любой момент. Он может как зависеть, так и не зависеть от `Master`-а.
> - `Slave` **должен** дождаться, когда сигналы `ARVALID` и `ARREADY` выставятся в единицу, прежде чем поднять сигнал `RVALID`, то есть строго после того, как произошел `handshake` по сигналам канала `Read Adress`.
> - `Slave` **не может** ожидать выставления в единицу `Master`-ом сигнала `RREADY`, чтобы поднять сигнал `RVALID`.
> - `Master` **может** поднять `RREADY` в любой момент, не ожидая сигнала `RVALID`.

### Зависимости транзакции записи
Рисунок ниже показывает зависимости сигналов для `handshake` транзакции записи.

При осуществлении транзакции записи необходимо взаимодействие трех каналов: `Write Adress`(AW), `Write Data`(W) и `Write Response`(B). Далее рассмотрим связи между сигналами `Valid` и `Ready` внутри этих каналов.

В общем случае зависимости выстраиваются следующие:

![](/doc/img/axi_writing_dependencies.png)

Разберем эти зависимости:

> - `Master` **не может** ожидать сигналы `AWREADY` или `WREADY` от `Slave-а` для выставления в единицу сигналов `AWVALID` или `WVALID`.
> - `Slave` может подождать выставления `AWVALID`, или `WVALID`, или оба сигнала, до выставления `AWREADY`
> - `Slave` **может** поднять `AWREADY` до того, как `Master` выставит в единицу сигналы `AWVALID` или `WVALID` (или оба).
> - `Slave` **может** подождать от `Master`-а сигналы `AWVALID` или `WVALID` (или оба) до выставления в единицу `WREADY`. Также `Slave` **может** поднять `WREADY`, не дожидаясь `AWVALID`, или `WVALID`, или обоих сигналов.
> - `Slave` **должен** дождаться, когда сигналы `AWVALID`, `AWREADY`, `WVALID`, `WREADY` выставятся в единицу, прежде чем поднять сигнал `BVALID`.
> - `Slave` **не может** ждать, пока `Master` установит в единицу `BREADY`, чтобы поднять `BVALID`.
> - `Master` **может** подождать `BVALID` до выставления в единицу `BREADY`. Также `Master` **может** поднять `BREADY`, не дожидаясь `BVALID`.

# Рекомендации для дополнительного ознакомления:

- Подробнее про `AI4-Lite` и в целом про `AMBA` можно узнать в официальной [спецификации](/doc/AXI4_specification.pdf).
